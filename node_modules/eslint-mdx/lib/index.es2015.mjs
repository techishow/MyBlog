import path from 'path';
import fs from 'fs';
import { cosmiconfigSync } from 'cosmiconfig';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import unified from 'unified';

const FALLBACK_PARSERS = [
  "@typescript-eslint/parser",
  "@babel/eslint-parser",
  "babel-eslint",
  "espree"
];
const JSX_TYPES = ["JSXElement", "JSXFragment"];
const isJsxNode = (node) => JSX_TYPES.includes(node.type);
const normalizeParser = (parser) => {
  if (parser) {
    if (typeof parser === "string") {
      parser = require(parser);
    }
    if (typeof parser === "object") {
      parser = "parseForESLint" in parser && parser.parseForESLint || "parse" in parser && parser.parse;
    }
    if (typeof parser !== "function") {
      throw new TypeError(`Invalid custom parser for \`eslint-mdx\`: ${parser}`);
    }
    return [parser];
  }
  const parsers = [];
  for (const fallback of FALLBACK_PARSERS) {
    try {
      const fallbackParser = require(fallback);
      const parserFn = "parseForESLint" in fallbackParser ? fallbackParser.parseForESLint : fallbackParser.parse;
      if (parserFn) {
        parsers.push(parserFn);
      }
    } catch (e) {
    }
  }
  return parsers;
};
const normalizePosition = (loc) => {
  const start = loc.start.offset;
  const end = loc.end.offset;
  return {
    range: [start, end],
    loc,
    start,
    end
  };
};
const hasProperties = (obj, properties) => typeof obj === "object" && obj && properties.every((property) => property in obj);
const getPositionAt = (code, offset) => {
  let currOffset = 0;
  const lines = code.split("\n");
  for (let index = 0; index < lines.length; index++) {
    const line = index + 1;
    const nextOffset = currOffset + lines[index].length;
    if (nextOffset >= offset) {
      return {
        line,
        column: offset - currOffset
      };
    }
    currOffset = nextOffset + 1;
  }
};
const restoreNodeLocation = (node, point) => {
  if (node && typeof node === "object") {
    for (const value of Object.values(node)) {
      restoreNodeLocation(value, point);
    }
  }
  if (!hasProperties(node, ["loc", "range"])) {
    return node;
  }
  let {
    loc: { start: startLoc, end: endLoc },
    range: [start, end]
  } = node;
  const range = [start += point.offset, end += point.offset];
  return Object.assign(node, {
    start,
    end,
    range,
    loc: {
      start: {
        line: point.line + startLoc.line,
        column: startLoc.column + (startLoc.line === 1 ? point.column : 0)
      },
      end: {
        line: point.line + endLoc.line,
        column: endLoc.column + (endLoc.line === 1 ? point.column : 0)
      }
    }
  });
};
const arrayify = (...args) => args.reduce((arr, curr) => {
  arr.push(...Array.isArray(curr) ? curr : curr == null ? [] : [curr]);
  return arr;
}, []);
const first = (items) => items && items[0];
const last = (items) => items && items[items.length - 1];

const requirePkg = (plugin, prefix, filePath) => {
  if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
    plugin = path.resolve(path.dirname(filePath), plugin);
  }
  prefix = prefix.endsWith("-") ? prefix : prefix + "-";
  const packages = [
    plugin,
    plugin.startsWith("@") ? plugin.replace("/", "/" + prefix) : prefix + plugin
  ];
  let error;
  for (const pkg of packages) {
    try {
      return require(pkg);
    } catch (err) {
      if (!error) {
        error = err;
      }
    }
  }
  throw error;
};
const getPhysicalFilename = (filename) => {
  try {
    if (fs.statSync(filename).isFile()) {
      return filename;
    }
  } catch (err) {
    if (err.code === "ENOTDIR") {
      return getPhysicalFilename(path.dirname(filename));
    }
  }
  return filename;
};
const remarkProcessor = unified().use(remarkParse).freeze();
const explorer = cosmiconfigSync("remark", {
  packageProp: "remarkConfig"
});
const processorCache = new Map();
const getRemarkProcessor = (searchFrom, isMdx) => {
  const initCacheKey = `${String(isMdx)}-${searchFrom}`;
  let cachedProcessor = processorCache.get(initCacheKey);
  if (cachedProcessor) {
    return cachedProcessor;
  }
  const result = explorer.search(searchFrom);
  const cacheKey = result ? `${String(isMdx)}-${result.filepath}` : "";
  cachedProcessor = processorCache.get(cacheKey);
  if (cachedProcessor) {
    return cachedProcessor;
  }
  if (result) {
    const { plugins = [], settings } = result.config || {};
    if (plugins.length > 0) {
      try {
        plugins.push([require.resolve("remark-lint-file-extension"), false]);
      } catch (e) {
      }
    }
    const initProcessor = remarkProcessor().use({ settings }).use(remarkStringify);
    if (isMdx) {
      initProcessor.use(remarkMdx);
    }
    cachedProcessor = plugins.reduce((processor, pluginWithSettings) => {
      const [plugin, ...pluginSettings] = arrayify(pluginWithSettings);
      return processor.use(typeof plugin === "string" ? requirePkg(plugin, "remark", result.filepath) : plugin, ...pluginSettings);
    }, initProcessor).freeze();
  } else {
    const initProcessor = remarkProcessor().use(remarkStringify);
    if (isMdx) {
      initProcessor.use(remarkMdx);
    }
    cachedProcessor = initProcessor.freeze();
  }
  processorCache.set(initCacheKey, cachedProcessor).set(cacheKey, cachedProcessor);
  return cachedProcessor;
};

const dotAllPolyfill = "[\0-\uFFFF]";
const attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
const singleQuoted = "'[^']*'";
const doubleQuoted = '"[^"]*"';
const jsProps = "{.*}".replace(".", dotAllPolyfill);
const attributeValue = "(?:" + unquoted + "|" + singleQuoted + "|" + doubleQuoted + "|" + jsProps + ")";
const attribute = "(?:\\s+" + attributeName + "(?:\\s*=\\s*" + attributeValue + ")?)";
const openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + attribute + "*\\s*>";
const closeTag = "<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>";
const selfClosingTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + attribute + "*\\s*\\/?>";
const comment = "<!--(?:[^-]|-(?:[^-]|-+[^->]))*-*-->";
const commentOpen = "(<!---*)";
const commentClose = "(-*-->)";
const commentContent = `${commentOpen}([\\s\\S]*?)${commentClose}`;
const OPEN_TAG_REGEX = new RegExp(`^(?:${openTag})$`);
const CLOSE_TAG_REGEX = new RegExp(`^(?:${closeTag})$`);
const OPEN_CLOSE_TAG_REGEX = new RegExp(`^(?:${openTag + "[^<]*" + closeTag})$`);
const SELF_CLOSING_TAG_REGEX = new RegExp(`^(?:${selfClosingTag})$`);
const COMMENT_REGEX = new RegExp(`^(?:${comment})$`);
const COMMENT_CONTENT_REGEX = new RegExp(commentContent);
const COMMENT_CONTENT_REGEX_GLOBAL = new RegExp(commentContent, "g");
const isOpenTag = (text) => OPEN_TAG_REGEX.test(text.trim());
const isCloseTag = (text) => CLOSE_TAG_REGEX.test(text.trim());
const isComment = (text) => COMMENT_REGEX.test(text.trim());
const isOpenCloseTag = (text) => OPEN_CLOSE_TAG_REGEX.test(text.trim());
const isSelfClosingTag = (text) => SELF_CLOSING_TAG_REGEX.test(text.trim());

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
class Traverse {
  constructor({ code, enter }) {
    this.code = code;
    this._enter = enter;
  }
  combineLeftJsxNodes(jsxNodes, parent) {
    var _a;
    const start = jsxNodes[0].position.start;
    const end = __spreadValues$1({}, last(jsxNodes).position.end);
    if (parent && ((_a = parent.position.indent) == null ? void 0 : _a.length) > 0) {
      end.offset += parent.position.indent.reduce((acc, indent, index) => acc + (index ? indent + 1 : 0), 0);
    }
    return {
      type: "jsx",
      data: jsxNodes[0].data,
      value: this.code.slice(start.offset, end.offset),
      position: {
        start,
        end
      }
    };
  }
  combineJsxNodes(nodes, parent) {
    let offset = 0;
    let hasOpenTag = false;
    const jsxNodes = [];
    const { length } = nodes;
    return nodes.reduce((acc, node, index) => {
      if (node.type === "jsx") {
        const value = node.value;
        if (isOpenTag(value)) {
          offset++;
          hasOpenTag = true;
          jsxNodes.push(node);
        } else {
          if (isCloseTag(value)) {
            offset--;
            jsxNodes.push(node);
          } else if (isComment(value) || isSelfClosingTag(value) || isOpenCloseTag(value)) {
            jsxNodes.push(node);
          } else {
            try {
              jsxNodes.push(...arrayify(parser.normalizeJsxNode(node, parent)));
            } catch (e) {
              if (!index) {
                offset++;
                hasOpenTag = true;
              }
              if (offset) {
                jsxNodes.push(node);
              } else {
                const { start } = node.position;
                throw Object.assign(new SyntaxError("unknown jsx node: " + JSON.stringify(value)), {
                  lineNumber: start.line,
                  column: start.column,
                  index: start.offset
                });
              }
            }
          }
          if (!offset) {
            const firstOpenTagIndex = jsxNodes.findIndex((node2) => typeof node2.value === "string" && isOpenTag(node2.value));
            if (firstOpenTagIndex === -1) {
              if (hasOpenTag) {
                acc.push(this.combineLeftJsxNodes(jsxNodes, parent));
              } else {
                acc.push(...jsxNodes);
              }
            } else {
              acc.push(...jsxNodes.slice(0, firstOpenTagIndex), this.combineLeftJsxNodes(jsxNodes.slice(firstOpenTagIndex), parent));
            }
            jsxNodes.length = 0;
          }
        }
      } else if (offset) {
        jsxNodes.push(node);
      } else {
        acc.push(node);
      }
      if (index === length - 1 && jsxNodes.length > 0) {
        acc.push(this.combineLeftJsxNodes(jsxNodes, parent));
      }
      return acc;
    }, []);
  }
  traverse(node, parent) {
    if (!node) {
      return;
    }
    if ("children" in node) {
      const parent2 = node;
      parent2.children = this.combineJsxNodes(parent2.children, parent2);
      for (const child of parent2.children) {
        this.traverse(child, parent2);
      }
    }
    this._enter(node, parent);
  }
}
const traverse = (root, options) => new Traverse(options).traverse(root);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const AST_PROPS = ["body", "comments", "tokens"];
const ES_NODE_TYPES = ["export", "import", "jsx"];
const LOC_ERROR_PROPERTIES = ["column", "lineNumber"];
const DEFAULT_EXTENSIONS = [".mdx"];
const MARKDOWN_EXTENSIONS = [".md"];
const PLACEHOLDER_FILE_PATH = "__placeholder__.mdx";
const DEFAULT_PARSER_OPTIONS = {
  comment: true,
  ecmaFeatures: {
    jsx: true
  },
  ecmaVersion: new Date().getUTCFullYear(),
  sourceType: "module",
  tokens: true,
  filePath: PLACEHOLDER_FILE_PATH,
  loc: true,
  range: true
};
const JSX_WRAPPER_START = "<$>";
const JSX_WRAPPER_END = "</$>";
const OFFSET = JSX_WRAPPER_START.length;
class Parser {
  constructor() {
    this._options = DEFAULT_PARSER_OPTIONS;
    this.parse = this.parse.bind(this);
    this.parseForESLint = this.parseForESLint.bind(this);
  }
  normalizeJsxNode(node, parent, options = this._options) {
    const value = node.value;
    if (node.type !== "jsx" || isComment(value)) {
      return node;
    }
    const commentContent = COMMENT_CONTENT_REGEX.exec(value);
    if (commentContent) {
      const comments = [];
      const {
        position: {
          start: { line, column, offset: startOffset }
        },
        data
      } = node;
      Object.assign(node, {
        data: __spreadProps(__spreadValues({}, data), {
          jsxType: "JSXElementWithHTMLComments",
          comments,
          inline: !!parent && parent.type !== "root"
        }),
        value: value.replace(COMMENT_CONTENT_REGEX_GLOBAL, (matched, $0, $1, $2, offset) => {
          const endOffset = offset + matched.length;
          const startLines = value.slice(0, offset).split("\n");
          const endLines = value.slice(0, endOffset).split("\n");
          const fixed = `{/${"*".repeat($0.length - 2)}${$1}${"*".repeat($2.length - 2)}/}`;
          const startLineOffset = startLines.length - 1;
          const endLineOffset = endLines.length - 1;
          comments.push({
            fixed,
            loc: {
              start: {
                line: line + startLineOffset,
                column: last(startLines).length + (startLineOffset ? 0 : column - 1),
                offset: startOffset + offset
              },
              end: {
                line: line + endLineOffset,
                column: last(endLines).length + (endLineOffset ? 0 : column - 1),
                offset: startOffset + endOffset
              }
            },
            origin: matched
          });
          return fixed;
        })
      });
    }
    return this._normalizeJsxNodes(node, options);
  }
  parse(code, options) {
    return this.parseForESLint(code, options).ast;
  }
  parseForESLint(code, options) {
    const extname = path.extname(options.filePath);
    const isMdx = [
      ...DEFAULT_EXTENSIONS,
      ...options.extensions || []
    ].includes(extname);
    const isMarkdown = [
      ...MARKDOWN_EXTENSIONS,
      ...options.markdownExtensions || []
    ].includes(extname);
    if (!isMdx && !isMarkdown) {
      return this._eslintParse(code, options);
    }
    const root = getRemarkProcessor(getPhysicalFilename(options.filePath), isMdx).parse(code);
    this._ast = __spreadProps(__spreadValues({}, normalizePosition(root.position)), {
      type: "Program",
      sourceType: options.sourceType || "module",
      body: [],
      comments: [],
      tokens: []
    });
    this._services = {
      JSXElementsWithHTMLComments: []
    };
    if (isMdx) {
      traverse(root, {
        code,
        enter: (node, parent) => {
          if (!ES_NODE_TYPES.includes(node.type)) {
            return;
          }
          for (const normalizedNode of arrayify(this.normalizeJsxNode(node, parent, options))) {
            this._nodeToAst(code, normalizedNode, options);
          }
        }
      });
    }
    return {
      ast: this._ast,
      services: this._services
    };
  }
  _eslintParse(code, options) {
    if (!this._parsers || options.parser !== this._options.parser) {
      this._parsers = normalizeParser(options.parser);
    }
    if (options.filePath && this._options !== options) {
      Object.assign(this._options, options);
    }
    let program;
    let parseError;
    for (const parser2 of this._parsers) {
      try {
        program = parser2(code, this._options);
        break;
      } catch (err) {
        if (!parseError) {
          parseError = err;
        }
      }
    }
    if (!program && parseError) {
      throw parseError;
    }
    return "ast" in program && program.ast ? program : { ast: program };
  }
  _normalizeJsxNodes(node, options) {
    const value = node.value;
    let program;
    try {
      program = this._eslintParse(`${JSX_WRAPPER_START}${value}${JSX_WRAPPER_END}`, options).ast;
    } catch (err) {
      if (hasProperties(err, LOC_ERROR_PROPERTIES)) {
        const {
          position: { start }
        } = node;
        if ("index" in err) {
          err.index += start.offset - OFFSET;
        } else if ("pos" in err) {
          err.pos += start.offset - OFFSET;
        }
        err.column = err.lineNumber > 1 ? err.column : err.column + start.column - OFFSET;
        err.lineNumber += start.line - 1;
        throw err;
      }
      return node;
    }
    const { expression } = program.body[0];
    if (!isJsxNode(expression) || expression.children.length <= 1) {
      return node;
    }
    const {
      position: {
        start: { line, offset }
      },
      data
    } = node;
    return expression.children.reduce((nodes, jsNode) => {
      if (!isJsxNode(jsNode)) {
        return nodes;
      }
      const {
        start: nodeStart,
        end: nodeEnd,
        loc: { start, end } = {
          start: { column: nodeStart, line: 1 },
          end: { column: nodeEnd, line: 1 }
        },
        range = [nodeStart, nodeEnd]
      } = jsNode;
      const startLine = line + start.line - 1;
      const endLine = line + end.line - 1;
      const startOffset = range[0] - OFFSET;
      const endOffset = range[1] - OFFSET;
      nodes.push({
        type: "jsx",
        data: nodes.length > 0 ? null : data,
        value: value.slice(startOffset, endOffset),
        position: {
          start: {
            line: startLine,
            column: line === startLine ? start.column - OFFSET : start.column,
            offset: offset + startOffset
          },
          end: {
            line: endLine,
            column: line === startLine ? end.column - OFFSET : end.column,
            offset: offset + endOffset
          }
        }
      });
      return nodes;
    }, []);
  }
  _nodeToAst(code, node, options) {
    if (node.data && node.data.jsxType === "JSXElementWithHTMLComments") {
      this._services.JSXElementsWithHTMLComments.push(node);
    }
    const value = node.value;
    const { loc, start, end } = normalizePosition(node.position);
    if (isComment(value)) {
      const comment = COMMENT_CONTENT_REGEX.exec(value)[2];
      this._ast.comments.push({
        type: "Block",
        value: comment,
        loc,
        range: [start, end]
      });
      return;
    }
    const startLine = loc.start.line - 1;
    let program;
    try {
      program = this._eslintParse(value, options).ast;
    } catch (e) {
      if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
        e.index += start;
        e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
        e.lineNumber += startLine;
      }
      throw e;
    }
    const startPoint = {
      line: startLine,
      column: getPositionAt(code, start).column,
      offset: start
    };
    for (const prop of AST_PROPS)
      this._ast[prop].push(...program[prop].map((item) => restoreNodeLocation(item, startPoint)));
  }
}
const parser = new Parser();
const { parse, parseForESLint } = parser;

export { AST_PROPS, CLOSE_TAG_REGEX, COMMENT_CONTENT_REGEX, COMMENT_CONTENT_REGEX_GLOBAL, COMMENT_REGEX, DEFAULT_EXTENSIONS, DEFAULT_PARSER_OPTIONS, ES_NODE_TYPES, FALLBACK_PARSERS, JSX_TYPES, LOC_ERROR_PROPERTIES, MARKDOWN_EXTENSIONS, OPEN_CLOSE_TAG_REGEX, OPEN_TAG_REGEX, PLACEHOLDER_FILE_PATH, Parser, SELF_CLOSING_TAG_REGEX, Traverse, arrayify, closeTag, comment, commentClose, commentContent, commentOpen, first, getPhysicalFilename, getPositionAt, getRemarkProcessor, hasProperties, isCloseTag, isComment, isJsxNode, isOpenCloseTag, isOpenTag, isSelfClosingTag, last, normalizeParser, normalizePosition, openTag, parse, parseForESLint, parser, processorCache, remarkProcessor, requirePkg, restoreNodeLocation, selfClosingTag, traverse };
